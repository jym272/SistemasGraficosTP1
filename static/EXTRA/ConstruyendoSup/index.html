<!doctype html>

<head>
    <script src="js/three.js"></script>
    <script src="js/jquery.js"></script>
    <script src="js/gl-matrix-3.3.0.js"></script>
    <script src="js/webgl-utils.js"></script>
    <script src="js/dat.gui.js"></script>
    <style>
        html {
            height: 100%;
        }

        body {
            padding: 0;
            margin: 0;
            height: 100%;;
        }

        #myCanvas {
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
    </style>
    <title>Superficies Parametricas</title>

</head>

<body>

<canvas id="myCanvas">
    Your browser does not support the HTML5 canvas element.
</canvas>
<script src="./modulo-geometria.js"></script>
<script src="./menu.js" type="text/javascript"></script>
<script>

    const vertexShaderFile = "vertex-shader.glsl";
    var modo = "edges"; // wireframe, smooth, edges
    let shaderProgram;
    //let time = 0;

    let gl;
    const mat4 = glMatrix.mat4;
    const mat3 = glMatrix.mat3;
    const vec3 = glMatrix.vec3;

    let earth;

    const $canvas = $("#myCanvas");
    let aspect = $canvas.width() / $canvas.height();

    var distanciaCamara = 3;
    var alturaCamara = 2;
    var velocidadAngular = 0.2;

    const lighting = "true";

    let vertexShaderSource;
    let fragmentShaderSource;

    const matrizProyeccion = mat4.create()
    const matrizVista = mat4.create();

    const menuInicial = new initMenu();

    function initGL(canvas) {


        try {
            gl = canvas.getContext("webgl");
            gl.canvas.width = $canvas.width();
            gl.canvas.height = $canvas.height();
        } catch (e) {
            console.error(e);
        }
        if (!gl) {
            alert("Could not initialise WebGL, sorry :-(");
        }
    }

    function loadShaders() {


        $.when(loadVS(), loadFS()).done(function (res1, res2) {
            //this code is this.executed when all ajax calls are done
            webGLStart();
        });

        function loadVS() {
            return $.ajax({
                url: "shaders/" + vertexShaderFile,
                success: function (result) {
                    vertexShaderSource = result;
                }
            });
        }

        function loadFS() {
            return $.ajax({
                url: "shaders/fragment-shader.glsl",
                success: function (result) {
                    fragmentShaderSource = result;
                }
            });
        }
    }

    function getShader(gl, code, type) {

        let shader;

        if (type == "fragment")
            shader = gl.createShader(gl.FRAGMENT_SHADER);
        else // "vertex"
            shader = gl.createShader(gl.VERTEX_SHADER);

        gl.shaderSource(shader, code);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.error(gl.getShaderInfoLog(shader));
            return null;
        }
        return shader;
    }

    function onResize() {
        gl.canvas.width = $canvas.width();
        gl.canvas.height = $canvas.height();
        aspect = $canvas.width() / $canvas.height();
    }

    function getShaderSource(url) {
        const req = new XMLHttpRequest();
        req.open("GET", url, false);
        req.send(null);
        return (req.status == 200) ? req.responseText : null;
    }

    function initShaders() {

        const fragmentShader = getShader(gl, vertexShaderSource, "vertex");
        const vertexShader = getShader(gl, fragmentShaderSource, "fragment");

        shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);

        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            alert("Could not initialise shaders");
        }

        gl.useProgram(shaderProgram);

        shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aPosition");
        gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

        shaderProgram.textureCoordAttribute = gl.getAttribLocation(shaderProgram, "aUv");
        gl.enableVertexAttribArray(shaderProgram.textureCoordAttribute);

        shaderProgram.vertexNormalAttribute = gl.getAttribLocation(shaderProgram, "aNormal");
        gl.enableVertexAttribArray(shaderProgram.vertexNormalAttribute);

        shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
        shaderProgram.mMatrixUniform = gl.getUniformLocation(shaderProgram, "uMMatrix");
        shaderProgram.vMatrixUniform = gl.getUniformLocation(shaderProgram, "uVMatrix");
        shaderProgram.nMatrixUniform = gl.getUniformLocation(shaderProgram, "uNMatrix");
        shaderProgram.samplerUniform = gl.getUniformLocation(shaderProgram, "uSampler");
        shaderProgram.useLightingUniform = gl.getUniformLocation(shaderProgram, "uUseLighting");
        shaderProgram.ambientColorUniform = gl.getUniformLocation(shaderProgram, "uAmbientColor");
        shaderProgram.frameUniform = gl.getUniformLocation(shaderProgram, "time");
        shaderProgram.lightingDirectionUniform = gl.getUniformLocation(shaderProgram, "uLightPosition");
        shaderProgram.directionalColorUniform = gl.getUniformLocation(shaderProgram, "uDirectionalColor");
    }




    function setMatrixUniforms(matrizModelado){

        gl.uniformMatrix4fv(shaderProgram.mMatrixUniform, false, matrizModelado);
        gl.uniformMatrix4fv(shaderProgram.vMatrixUniform, false, matrizVista);
        gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, matrizProyeccion);

        const normalMatrix = mat3.create();
        mat3.fromMat4(normalMatrix, matrizModelado); // normalMatrix= (inversa(traspuesta(matrizModelado)));

        mat3.invert(normalMatrix, normalMatrix);
        mat3.transpose(normalMatrix, normalMatrix);

        gl.uniformMatrix3fv(shaderProgram.nMatrixUniform, false, normalMatrix);
    }
    const tubo = new Tubo();
    const esferaa = new Esfera(0.4);


    function drawScene(time) {
        // Se configura el viewport dentro del "canvas".
        // En este caso se utiliza toda el área disponible
        gl.viewport(0, 0, $canvas.width(), $canvas.height());

        // Se habilita el color de borrado para la pantalla (Color Buffer) y otros buffers
        gl.clearColor(0.2, 0.2, 0.2, 1);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        // Se configura la matriz de proyección
        mat4.identity(matrizProyeccion);
        mat4.perspective(matrizProyeccion, 30, aspect, 0.1, 100.0);
        mat4.scale(matrizProyeccion, matrizProyeccion, [1, -1, 1]); // parche para hacer un flip de Y, parece haber un bug en glmatrix

        // Se inicializan las constiables asociadas con la Iluminación

        gl.uniform1f(shaderProgram.frameUniform, time / 10.0);
        gl.uniform3f(shaderProgram.ambientColorUniform, 0.6, 0.6, 0.6);
        gl.uniform3f(shaderProgram.directionalColorUniform, 1.2, 1.1, 0.7);
        gl.uniform1i(shaderProgram.useLightingUniform, (lighting == "true"));

        // Definimos la ubicación de la camara

        mat4.lookAt(matrizVista,
            vec3.fromValues(0, alturaCamara, distanciaCamara),
            vec3.fromValues(0, 0, 0),
            vec3.fromValues(0, 1, 0)
        );

        const lightPosition = [10.0, 0.0, 3.0];
        gl.uniform3fv(shaderProgram.lightingDirectionUniform, lightPosition);


        const matrizModelado= mat4.create()
       // mat4.rotate(matrizModelado, matrizModelado, time * 0.5, [0, 1, 0]);

        mat4.translate( matrizModelado,     // destination matrix
            matrizModelado,     // matrix to translate
            [0.0, 0.0, 1]);  // amount to translate

        // mat4.rotate(matrizModelado, matrizModelado, 2*Math.PI*time, [1,0,0]);

        setMatrixUniforms(matrizModelado);
        dibujarGeometria(tubo);

        
        const matrizModelado2= mat4.create()
        mat4.rotate(matrizModelado2, matrizModelado, 2*Math.PI*time, [0,1,0]);
        mat4.translate(matrizModelado2, matrizModelado2, [0.0, 0.0, 0.5]);

        setMatrixUniforms(matrizModelado2);
        dibujarGeometria(esferaa);


        const matrizModelado3= mat4.create()
        mat4.rotate(matrizModelado3, matrizModelado, -2*Math.PI*time, [0,1,0]);
        mat4.translate(matrizModelado3, matrizModelado3, [0.0, 1.0, 0.5]);

        setMatrixUniforms(matrizModelado3);
        dibujarGeometria(esferaa);

        const matrizModelado4= mat4.create()
        mat4.rotate(matrizModelado4, matrizModelado, -Math.PI*time, [0,1,0]);
        mat4.translate(matrizModelado4, matrizModelado4, [0.0, 2.0, 0.5]);

        setMatrixUniforms(matrizModelado4);
        dibujarGeometria(esferaa);
        

    }


    

    const clock = new THREE.Clock()
    const tick = () =>{
    //console.log("tickeando")
        const time = clock.getElapsedTime()

        drawScene(time);
    
        window.requestAnimationFrame(tick)
    }

    /*
    function tick() {
        requestAnimFrame(tick);
        time += 1 / 60;


        drawScene();
    }
    */
    function webGLStart() {

        let canvas = document.getElementById("myCanvas");
        initGL(canvas);
        initShaders();

        gl.clearColor(66.2, 0.2, 0.2, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.enable(gl.DEPTH_TEST);

        $(window).on("resize", onResize);
        menuInicial.show();
        tick();
    }

    // cuando el documento HTML esta completo, iniciamos la aplicación
    $(document).ready(function () {
        loadShaders();
    })

</script>

</body>

</html>